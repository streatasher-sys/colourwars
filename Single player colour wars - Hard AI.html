<!DOCTYPE html>
<html>
<head>
  <title>Chain Reaction — Single Player vs Hard AI</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; margin-top: 30px; font-family: sans-serif; }
    canvas { border: 2px solid black; display: block; }
    #turnIndicator { margin-bottom: 10px; font-size: 18px; font-weight: bold; min-height: 1.5em; }
    #options { margin-bottom: 10px; display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
    #options label { cursor: pointer; user-select: none; }
    #aiStatus { margin-top: 8px; font-size: 14px; color: #666; min-height: 1.2em; }
  </style>
</head>
<body>
<div id="turnIndicator">Your turn</div>
<div id="options"><label><input type="checkbox" id="animateCheckbox" checked> Animate explosions</label></div>
<canvas id="boardCanvas" width="350" height="350"></canvas>
<div id="aiStatus"></div>

<script>
const rows = 7;
const cols = 7;
const N = rows * cols;
const cellSize = 50;
const red = 1;
const green = -1;

const WIN_SCORE = 1e8;
const LOSS_SCORE = -1e8;
const AI_TIME_LIMIT_MS = 5000;
const MAX_DEPTH = 12;
const MAX_ANIMATION_STEPS = 60;
const EXPLOSION_DELAY_MS = 380;
const TT_SIZE = 65536;

function idx(r, c) { return r * cols + c; }

// --- Typed-array board (single allocation, no object churn) ---
const board = {
  count: new Uint8Array(N),
  owner: new Int8Array(N)
};
board.owner[idx(1, 1)] = red;
board.count[idx(1, 1)] = 1;
board.owner[idx(5, 5)] = green;
board.count[idx(5, 5)] = 1;

let currentPlayer = red;
let gameEnded = false;
let redHasPlayed = true;
let greenHasPlayed = true;
let isAnimating = false;

const canvas = document.getElementById("boardCanvas");
const ctx = canvas.getContext("2d");
const aiStatusEl = document.getElementById("aiStatus");

// --- Undo diffs (per-level, no full-board copy) ---
const DIFF_CELLS = 49;
const diffIdx = new Uint16Array((MAX_DEPTH + 1) * DIFF_CELLS);
const diffCount = new Uint8Array((MAX_DEPTH + 1) * DIFF_CELLS);
const diffOwner = new Int8Array((MAX_DEPTH + 1) * DIFF_CELLS);
const diffLen = new Uint8Array(MAX_DEPTH + 1);
let recLevel = -1;

function diffBase(d) { return d * DIFF_CELLS; }

function recordCell(b, i) {
  if (recLevel < 0) return;
  const base = diffBase(recLevel);
  const pos = diffLen[recLevel];
  diffIdx[base + pos] = i;
  diffCount[base + pos] = b.count[i];
  diffOwner[base + pos] = b.owner[i];
  diffLen[recLevel]++;
}

function undoDiff(b, level) {
  const base = diffBase(level);
  let pos = diffLen[level];
  while (pos--) {
    const i = diffIdx[base + pos];
    b.count[i] = diffCount[base + pos];
    b.owner[i] = diffOwner[base + pos];
  }
  diffLen[level] = 0;
}

// --- Transposition table (fixed size, no recomputation) ---
const ttHash = new Uint32Array(TT_SIZE);
const ttScore = new Int32Array(TT_SIZE);
const ttDepth = new Int8Array(TT_SIZE);
const ttFlag = new Uint8Array(TT_SIZE); // 0=exact, 1=lower, 2=upper

function hashBoard(b) {
  let h = 0;
  for (let i = 0; i < N; i++)
    h = ((h * 31) + b.count[i] * 2 + (b.owner[i] + 1)) | 0;
  return h >>> 0;
}

const ttOut = { score: 0, flag: 0 };
function ttLookup(h, depth, out) {
  const i = h % TT_SIZE;
  if (ttHash[i] !== h || ttDepth[i] < depth) return false;
  out.score = ttScore[i];
  out.flag = ttFlag[i];
  return true;
}

function ttStore(h, depth, score, flag) {
  const i = h % TT_SIZE;
  ttHash[i] = h;
  ttScore[i] = score;
  ttDepth[i] = depth;
  ttFlag[i] = flag;
}

// --- Pre-allocated neighbors (no array allocation in hot path) ---
const NEIGHBORS_Out = new Uint8Array(8);

function neighborsCount(r, c) {
  let n = 0;
  if (r > 0) { NEIGHBORS_Out[n++] = r - 1; NEIGHBORS_Out[n++] = c; }
  if (r < rows - 1) { NEIGHBORS_Out[n++] = r + 1; NEIGHBORS_Out[n++] = c; }
  if (c > 0) { NEIGHBORS_Out[n++] = r; NEIGHBORS_Out[n++] = c - 1; }
  if (c < cols - 1) { NEIGHBORS_Out[n++] = r; NEIGHBORS_Out[n++] = c + 1; }
  return n >>> 1;
}

// --- Pre-allocated moves buffer ---
const movesBuf = new Int8Array(98);
let movesCount = 0;

function criticalMass() { return 4; }
const MAX_ORBS = 8;

// --- Game logic (typed-array + optional diff recording) ---
function makeMove(b, row, col, player) {
  if (row < 0 || row >= rows || col < 0 || col >= cols) return false;
  const i = idx(row, col);
  if (b.owner[i] !== player) return false;
  recordCell(b, i);
  b.count[i] += 1;
  b.owner[i] = player;
  return true;
}

function isUnstable(b, r, c) {
  return b.count[idx(r, c)] >= criticalMass();
}

function explode(b, row, col, player) {
  const i = idx(row, col);
  const count = b.count[i];
  const orbsPerNeighbor = count - 3;
  recordCell(b, i);
  b.count[i] = 0;
  b.owner[i] = 0;
  const nn = neighborsCount(row, col);
  for (let k = 0; k < nn; k++) {
    const r2 = NEIGHBORS_Out[k * 2], c2 = NEIGHBORS_Out[k * 2 + 1];
    const j = idx(r2, c2);
    recordCell(b, j);
    b.count[j] = Math.min(MAX_ORBS, b.count[j] + orbsPerNeighbor);
    b.owner[j] = player;
  }
}

function resolve(b, player) {
  let changed = true;
  while (changed) {
    changed = false;
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        if (isUnstable(b, r, c)) {
          explode(b, r, c, player);
          changed = true;
          const w = gameOver();
          if (w !== 0) return w;
        }
  }
  return 0;
}

function resolveOneStep(b, player) {
  let changed = false;
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (isUnstable(b, r, c)) {
        explode(b, r, c, player);
        changed = true;
      }
  return changed;
}

// --- Animation: single closure, state machine (no recursive setTimeout) ---
let animationState = null;

function animationTick() {
  if (!animationState) return;
  const s = animationState;
  s.steps++;
  if (!resolveOneStep(s.board, s.player)) {
    s.onDone();
    animationState = null;
    return;
  }
  if (gameOver() !== 0) {
    s.onDone();
    animationState = null;
    return;
  }
  drawBoard();
  if (s.steps >= MAX_ANIMATION_STEPS) {
    resolve(s.board, s.player);
    drawBoard();
    s.onDone();
    animationState = null;
    return;
  }
  setTimeout(animationTick, EXPLOSION_DELAY_MS);
}

function resolveAnimated(b, player, onDone) {
  animationState = { board: b, player, onDone, steps: 0 };
  setTimeout(animationTick, EXPLOSION_DELAY_MS);
}

function getValidMoves(b, player) {
  movesCount = 0;
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (b.owner[idx(r, c)] === player) {
        movesBuf[movesCount * 2] = r;
        movesBuf[movesCount * 2 + 1] = c;
        movesCount++;
      }
}

function gameOverForSearch(b) {
  let redOrbs = 0, greenOrbs = 0;
  for (let i = 0; i < N; i++) {
    if (b.owner[i] === red) redOrbs += b.count[i];
    if (b.owner[i] === green) greenOrbs += b.count[i];
  }
  if (redOrbs > 0 && greenOrbs === 0) return green;
  if (greenOrbs > 0 && redOrbs === 0) return red;
  return 0;
}

function evaluate(b) {
  let redOrbs = 0, greenOrbs = 0, redCells = 0, greenCells = 0;
  let greenNearCritical = 0, redNearCritical = 0;
  for (let i = 0; i < N; i++) {
    const o = b.owner[i], c = b.count[i];
    if (o === red) {
      redOrbs += c;
      redCells++;
      if (c >= 3) redNearCritical += c;
    } else if (o === green) {
      greenOrbs += c;
      greenCells++;
      if (c >= 3) greenNearCritical += c;
    }
  }
  return (greenOrbs - redOrbs) * 10 + (greenCells - redCells) * 3 + (greenNearCritical - redNearCritical) * 2;
}

function scoreMoveOrdering(b, row, col, player) {
  const i = idx(row, col);
  let s = b.count[i] * 4 + (b.count[i] === 3 ? 8 : 0);
  const nn = neighborsCount(row, col);
  for (let k = 0; k < nn; k++) {
    const r2 = NEIGHBORS_Out[k * 2], c2 = NEIGHBORS_Out[k * 2 + 1];
    const o = b.owner[idx(r2, c2)];
    if (o !== 0 && o !== player) s += 6;
    if (o === player && b.count[idx(r2, c2)] >= 2) s += 2;
  }
  const center = (rows - 1) / 2;
  s -= Math.abs(row - center) + Math.abs(col - center);
  return s;
}

let searchStartTime = 0;
let searchAbort = false;

function applyMoveInPlace(b, row, col, player, saveIndex) {
  recLevel = saveIndex;
  diffLen[saveIndex] = 0;
  makeMove(b, row, col, player);
  resolve(b, player);
  recLevel = -1;
}

function minimax(b, depth, alpha, beta, isAITurn, saveIndex) {
  if (searchAbort) return 0;
  if (Date.now() - searchStartTime > AI_TIME_LIMIT_MS) {
    searchAbort = true;
    return evaluate(b);
  }

  const winner = gameOverForSearch(b);
  if (winner === green) return WIN_SCORE - (100 - depth);
  if (winner === red) return LOSS_SCORE + (100 - depth);
  if (depth <= 0) return evaluate(b);

  const h = hashBoard(b);
  if (ttLookup(h, depth, ttOut)) {
    if (ttOut.flag === 0) return ttOut.score;
    if (ttOut.flag === 1 && ttOut.score >= beta) return ttOut.score;
    if (ttOut.flag === 2 && ttOut.score <= alpha) return ttOut.score;
  }

  const player = isAITurn ? green : red;
  getValidMoves(b, player);
  if (movesCount === 0) {
    const sc = evaluate(b);
    ttStore(h, depth, sc, 0);
    return sc;
  }

  let bestScore = isAITurn ? LOSS_SCORE - 1 : WIN_SCORE + 1;
  let flag = 0;

  if (isAITurn) {
    for (let m = 0; m < movesCount; m++) {
      const r = movesBuf[m * 2], c = movesBuf[m * 2 + 1];
      applyMoveInPlace(b, r, c, green, saveIndex);
      const sc = minimax(b, depth - 1, alpha, beta, false, saveIndex + 1);
      undoDiff(b, saveIndex);
      if (sc > bestScore) bestScore = sc;
      alpha = Math.max(alpha, sc);
      if (beta <= alpha) { flag = 2; break; }
    }
  } else {
    for (let m = 0; m < movesCount; m++) {
      const r = movesBuf[m * 2], c = movesBuf[m * 2 + 1];
      applyMoveInPlace(b, r, c, red, saveIndex);
      const sc = minimax(b, depth - 1, alpha, beta, true, saveIndex + 1);
      undoDiff(b, saveIndex);
      if (sc < bestScore) bestScore = sc;
      beta = Math.min(beta, sc);
      if (beta <= alpha) { flag = 1; break; }
    }
  }

  if (bestScore <= alpha) flag = 2;
  else if (bestScore >= beta) flag = 1;
  ttStore(h, depth, bestScore, flag);
  return bestScore;
}

function getBestMove() {
  getValidMoves(board, green);
  if (movesCount === 0) return null;
  if (movesCount === 1) return { move: [movesBuf[0], movesBuf[1]], depth: 0 };

  for (let i = 0; i < movesCount - 1; i++)
    for (let j = i + 1; j < movesCount; j++) {
      const sa = scoreMoveOrdering(board, movesBuf[i * 2], movesBuf[i * 2 + 1], green);
      const sb = scoreMoveOrdering(board, movesBuf[j * 2], movesBuf[j * 2 + 1], green);
      if (sb > sa) {
        const r0 = movesBuf[i * 2], c0 = movesBuf[i * 2 + 1];
        movesBuf[i * 2] = movesBuf[j * 2];
        movesBuf[i * 2 + 1] = movesBuf[j * 2 + 1];
        movesBuf[j * 2] = r0;
        movesBuf[j * 2 + 1] = c0;
      }
    }

  searchStartTime = Date.now();
  searchAbort = false;
  ttHash.fill(0);
  let bestR = movesBuf[0], bestC = movesBuf[1];
  let bestScore = LOSS_SCORE - 1;
  let completedDepth = 0;

  for (let depth = 1; depth <= MAX_DEPTH && !searchAbort; depth++) {
    let alpha = LOSS_SCORE - 1;
    let depthBestR = -1, depthBestC = -1;
    let depthBestScore = LOSS_SCORE - 1;

    for (let m = 0; m < movesCount; m++) {
      if (searchAbort) break;
      const r = movesBuf[m * 2], c = movesBuf[m * 2 + 1];
      applyMoveInPlace(board, r, c, green, 0);
      const sc = minimax(board, depth - 1, alpha, WIN_SCORE + 1, false, 1);
      undoDiff(board, 0);
      if (sc > depthBestScore) {
        depthBestScore = sc;
        depthBestR = r;
        depthBestC = c;
      }
      alpha = Math.max(alpha, sc);
    }

    if (searchAbort) break;
    if (depthBestR >= 0) {
      bestR = depthBestR;
      bestC = depthBestC;
      bestScore = depthBestScore;
      completedDepth = depth;
    }
  }

  return { move: [bestR, bestC], depth: completedDepth };
}

function gameOver(b) {
  let redOrbs = 0, greenOrbs = 0;
  for (let i = 0; i < N; i++) {
    if (board.owner[i] === red) redOrbs += board.count[i];
    if (board.owner[i] === green) greenOrbs += board.count[i];
  }
  if (redOrbs > 0 && greenOrbs === 0 && greenHasPlayed) return red;
  if (greenOrbs > 0 && redOrbs === 0 && redHasPlayed) return green;
  return 0;
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const i = idx(r, c);
      ctx.strokeStyle = "black";
      ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
      const cnt = board.count[i], own = board.owner[i];
      if (cnt > 0) {
        ctx.fillStyle = own === red ? "red" : "green";
        const radius = 10 + 5 * (cnt - 1);
        ctx.beginPath();
        ctx.arc(c * cellSize + cellSize / 2, r * cellSize + cellSize / 2, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "white";
        ctx.font = "bold 16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(cnt, c * cellSize + cellSize / 2, r * cellSize + cellSize / 2);
      }
      if (isUnstable(board, r, c)) {
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 3;
        ctx.strokeRect(c * cellSize + 1, r * cellSize + 1, cellSize - 2, cellSize - 2);
        ctx.lineWidth = 1;
      }
    }
  }
}

const turnEl = document.getElementById("turnIndicator");

function updateTurnIndicator() {
  if (gameEnded) return;
  turnEl.textContent = currentPlayer === red ? "Your turn" : "AI's turn";
  aiStatusEl.textContent = "";
}

function finishMove() {
  isAnimating = false;
  const winner = gameOver();
  if (winner !== 0) {
    gameEnded = true;
    const msg = winner === red ? "You win!" : "AI wins!";
    turnEl.textContent = msg;
    aiStatusEl.textContent = "";
    setTimeout(() => alert(msg), 10);
    return;
  }
  currentPlayer = -currentPlayer;
  updateTurnIndicator();
  if (currentPlayer === green) {
    aiStatusEl.textContent = "AI thinking…";
    drawBoard();
    setTimeout(() => aiTurn(), 50);
  }
}

function aiTurn() {
  const result = getBestMove();
  const elapsed = ((Date.now() - searchStartTime) / 1000).toFixed(1);
  if (result === null) {
    aiStatusEl.textContent = "AI has no moves.";
    currentPlayer = red;
    updateTurnIndicator();
    return;
  }
  const [row, col] = result.move;
  aiStatusEl.textContent = "Searched " + result.depth + " move(s) ahead in " + elapsed + "s.";
  makeMove(board, row, col, green);
  const useAnimation = document.getElementById("animateCheckbox").checked;
  if (useAnimation) {
    isAnimating = true;
    drawBoard();
    resolveAnimated(board, green, function onAnimDone() {
      drawBoard();
      finishMove();
    });
  } else {
    resolve(board, green);
    drawBoard();
    finishMove();
  }
}

canvas.addEventListener("click", (e) => {
  if (gameEnded || isAnimating || currentPlayer !== red) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  const row = Math.floor(y / cellSize);
  const col = Math.floor(x / cellSize);

  if (!makeMove(board, row, col, red)) return;

  const useAnimation = document.getElementById("animateCheckbox").checked;
  if (useAnimation) {
    isAnimating = true;
    drawBoard();
    resolveAnimated(board, red, function onAnimDone() {
      drawBoard();
      finishMove();
    });
  } else {
    resolve(board, red);
    drawBoard();
    finishMove();
  }
});

drawBoard();
updateTurnIndicator();
</script>
</body>
</html>
